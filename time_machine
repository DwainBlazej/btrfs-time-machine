#!/usr/bin/env ruby
require 'optparse'
require 'date'
require 'time'
require 'chronic'
require 'yaml'
require 'fileutils'
require 'shellwords'

VER='0.4'

### SETUP THE COMMAND LINE OPTIONS ###############################################
options = {}
optparse = OptionParser.new do|opts|
  # Set a banner, displayed at the top
  # of the help screen.
  opts.banner = "Usage: #{__FILE__} [options]"

  # Define the options, and what they do
  options[:config] = nil
  opts.on( '-c', '--config FILE', 'Config file to use.' ) do|file|
    options[:config] = file
  end

  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end

  options[:sources] = nil
  opts.on( '-s', '--sources FILE', 'Sources file to use.' ) do|file|
    options[:sources] = file
  end

  #options[:verbose] = false
  #opts.on( '-v', '--verbose', 'Output more information' ) do
  #  options[:verbose] = true
  #end
end

optparse.parse!

#VERBOSE = options[:verbose]
CONFIG = options[:config] ? options[:config] : File.dirname(__FILE__)+"/config.yml"
SOURCES = options[:sources] ? options[:sources] : File.dirname(__FILE__)+"/sources.yml"

#############################################################################################

raise "Config file: `#{CONFIG}' could not be found" unless File.exist? CONFIG
raise "Sources file: `#{SOURCES}' could not be found" unless File.exist? SOURCES

cfg = YAML.load_file(CONFIG)
@sources = YAML.load_file(SOURCES)
@dest_device_uuid = cfg['dest_device_uuid']
@backup_mount_point = cfg['backup_mount_point']
@log_file = cfg['log_file']
@device = `blkid | grep '#{cfg['dest_device_uuid']}'`.split(':').first
@snapshot_dir = "#{@backup_mount_point}/snapshots"
@snapshot_max_age = cfg['snapshot_max_age']
@lock_file = cfg['lock_file']
@hostname = `hostname -s`.strip
@email = cfg['alert_email'] || nil

@rsync_options = cfg['rsync_options']
@mount_options = cfg['mount_options']

@alerts = [] # an empty array to store alerts that will be emailed

def lock()
  if locked?
    message = "It seems another backup is still running, or previous backup did not complete.  If you are sure that there are no backups currently running then try deleting the lockfile at `#{@lock_file}'."

    alert message
    send_alerts
    exit 1
  end
  FileUtils.touch @lock_file
end

def unlock() FileUtils.rm @lock_file end
def locked?() File.exist? @lock_file end

def log(message)
  date = Time.now.asctime

  message.each_line do |line|
    log = File.open(@log_file, 'a')
    log.puts "#{date} BTRFS Time Machine: #{message}"
    log.close
  end
end

def alert(message)
  log(message)
  @alerts.push message
end

def alert_and_abort(message)
  alert("#{message}")
  alert("Backup aborting due to fatal error")
  send_alerts
  unlock
  exit 1
end

def send_alerts()
  return 0 if @email.nil? || @alerts.count == 0

  subject = "BTRFS Time Machine failed on #{@hostname}"
  message = ''

  @alerts.each do |alert|
    message += "* #{alert}\n"
  end

  message += "\nFor more details check the log file at '#{@hostname}:#{@log_file}'."

  `echo #{message.shellescape} | mail -s "#{subject}" #{@email}`
end

def mount(device,mount_point)
  alert_and_abort "You did not provide me with a device and mount point." unless device && mount_point
  unless is_mounted?(device,mount_point) then
    log "Mounting #{device} to #{mount_point}"
    `sudo mount #{device} #{mount_point}`
  end
  alert_and_abort "Could not mount #{@device} to #{@backup_mount_point}" unless $?.success?
  $?.success?
end

def remount_as(option,device,mount_point)
  alert_and_abort "I don't have a mount option, device and mount point." unless option && device && mount_point
  alert_and_abort "Cannot remount because #{mount_point} is not mounted" unless is_mounted?(device,mount_point)
  log "Remounting #{mount_point} as #{option}"

  mount_opts = ['remount']
  mount_opts.push(@mount_options) unless @mount_options.nil?
  mount_opt_str = mount_opts.join(',')

  `sudo mount -o #{mount_opt_str},#{option} #{device} #{mount_point}`
  alert_and_abort "mount #{device} as #{option} failed" unless $?.success?
  $?.success?
end

def is_mounted?(device,mount_point)
  alert_and_abort "is_mounted says: You did not provide me with a device and mount point." unless device && mount_point
  found = false
  File.open('/proc/mounts', 'r').each_line do |line|
    found = true if line.include? mount_point
  end
  found
end

def command_path(command)
  cmd_path=`which #{command}`.strip
  alert_and_abort "#{command}: command not found" if cmd_path.empty?
  cmd_path
end

def meta_save
  meta_file = File.join(@backup_mount_point, 'latest', 'meta.yml')
  File.open(meta_file, 'w') do |file|
    file.puts "created_at: '#{Time.now}'"
  end
end

def meta_read(meta_file)
  YAML.load_file meta_file
end

def rsync
  @sources.each do |src_data|
    src = src_data['source']
    dst = File.expand_path("#{@backup_mount_point}/latest/#{src}")
    rsync = command_path('rsync')
    rsync_opts = '-av --numeric-ids --delete --delete-excluded --human-readable --inplace'

    unless @rsync_options.nil?
      rsync_opts += ' ' + @rsync_options.join(' ')
    end

    if src_data.key? 'exclusions' then
      src_data['exclusions'].each do |exclusion|
        exclusion.gsub!(/^\.\//, '')                  # drop off the ./ because rsync doesn't like em.
        rsync_opts += " --exclude '#{exclusion}'"
      end
    end

    alert_and_abort "rsync says: I need a source and destination" unless src && dst
    alert_and_abort "Could not create #{dst} directory" unless FileUtils.mkdir_p dst

    # start the backup
    log "Starting the backup."
    `sudo #{rsync} #{rsync_opts} #{src}/ #{dst} >> #{@log_file} 2>&1` # src needs a trailing slash on dir or it'll go in wrong dir.
    alert "Failed to backup `#{src}'" unless $?.success?
    meta_save
  end
end

def btrfs_scan()
  `sudo btrfsctl -a >> #{@log_file} 2>&1`
end

def btrfs_volume?(path)
  return false unless File.directory? path
  return true if File.stat(path).ino == 256
  false
end

def btrfs_snapshot_required?(snapshot_dir)
  #TODO: get rid of the repetition.
  required = true
  unit = "hour" if snapshot_dir.match /hourly/
  unit = "day" if snapshot_dir.match /daily/
  unit = "week" if snapshot_dir.match /weekly/
  unit = "month" if snapshot_dir.match /monthly/
  unit = "year" if snapshot_dir.match /yearly/

  snapshots = Dir.entries snapshot_dir
  snapshots.delete ".."
  snapshots.delete "."

  snapshots.each do |snapshot|
    snapshot_taken_at = Time.parse(meta_read(File.join(snapshot_dir, snapshot, 'meta.yml'))["created_at"])
    required = false if snapshot_taken_at < Chronic.parse("1 #{unit} ago")
  end
  required
end

def btrfs_snapshot_expired?(snapshot_dir)
  #TODO: get rid of the repetition.
  expired = false
  unit = "hour" if snapshot_dir.match /hourly/
  unit = "day" if snapshot_dir.match /daily/
  unit = "week" if snapshot_dir.match /weekly/
  unit = "month" if snapshot_dir.match /monthly/
  unit = "year" if snapshot_dir.match /yearly/
  frequency = "hourly" if snapshot_dir.match /hourly/
  frequency = "daily" if snapshot_dir.match /daily/
  frequency = "weekly" if snapshot_dir.match /weekly/
  frequency = "monthly" if snapshot_dir.match /monthly/
  frequency = "yearly" if snapshot_dir.match /yearly/

  snapshot_taken_at = Time.parse(meta_read(File.join(snapshot_dir, 'meta.yml'))["created_at"])
  expired = true if snapshot_taken_at > Chronic.parse("#{@snapshot_max_age[frequency].to_i} #{unit} ago")
  expired
end

def btrfs_snapshot
  %w[hourly daily weekly monthly yearly].each do |frequency|
    snap_dir = File.join(@snapshot_dir, frequency, Time.now.strftime("%Y-%m-%d %H:%M:%S"))
    btrfs_take_snapshot snap_dir
  end
end

def btrfs_take_snapshot(path)
  return true unless btrfs_snapshot_required?(File.split(path).first)
  FileUtils.mkdir_p File.split(path).first     # make sure that parent dir for snapshot exists
  unless File.directory?(path)
    log "Saving snapshot to `#{path}'"
    `sudo btrfs subvolume snapshot #{File.join(@backup_mount_point, 'latest')} '#{path}' >> #{@log_file} 2>&1`
    alert "Failed to make snapshot in `#{path}'" unless $?.success?
  end
end

def btrfs_delete_snapshot(date)
  log "deleting snapshot from #{date}"
  `sudo btrfs subvolume delete '#{@snapshot_dir}/#{date}' >> #{@log_file} 2>&1`
end

def btrfs_snapshot_rotate
  %w[hourly daily weekly yearly].each do |frequency|
    snapshot_dir = File.join(@snapshot_dir, frequency)
    snapshots = Dir.entries snapshot_dir
    snapshots.delete ".."
    snapshots.delete "."

    snapshots.each do |snapshot|
      btrfs_delete_snapshot File.join(frequency, snapshot) if btrfs_snapshot_expired? File.join(snapshot_dir, snapshot)
    end
  end
end

lock
log "BTRFS time machine version #{VER} started."
#btrfs_scan

# mount the backup filesystem
mount @device, @backup_mount_point

# backup filesystem needs to be btrfs for snapshots.
path = File.join(@backup_mount_point, "latest")
unless btrfs_volume? path
  alert_and_abort "Subvolume was not found at `#{path}'. Try running `btrfs subvolume create #{path}'."
end

remount_as "rw", @device, @backup_mount_point

rsync

btrfs_snapshot
btrfs_snapshot_rotate
remount_as "ro", @device, @backup_mount_point

log "Finished Successfully!"
send_alerts
unlock
